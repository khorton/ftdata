#!/usr/bin/perl## fdr.pl# Flight Data Recorder# Acquires data from multiple sources# Displays and saves data to file# Perl script to record serial data various flight instruments# High resolution computer time is appended to each data record # to facilitate time sync with other data.## Default units are: 'm', 'm/s', 'degC', 'ddd.dddddd' for position, 'ddd.ddd' for angles/direction## Inspired by Kevin Horton and his RV-8 projectmy (%simulate) = ();# Set to 1 for simulated inputs of NMEA and D10 data, 0 for real data$simulate{serial} = 1;use warnings;use strict;use Time::HiRes qw( time sleep gettimeofday );use POSIX;use Tk;use Tk::BrowseEntry;use Tk::Label;use Tk::Dialog;use vars qw( $OS_win );# Detect Operating system and load appropiate serial port moduleBEGIN {        $OS_win = ($^O eq "MSWin32") ? 1 : 0;        if ($OS_win) {            eval "use Win32::SerialPort";	    die "$@\n" if ($@);        }        else {            eval "use Device::SerialPort";	    die "$@\n" if ($@);        }} # End BEGIN# Global variables# Hash containing all data, ONE scan of the most recent data for all devices# Format for accessig data is $data{device name}{data field};my (%devices); # Hash of ALL devices that are defined and all available datamy (@device_list) = (); # List of active devices, could have multiple entries for each device typemy (@device_type);  # List of all available devices, one entry per device typemy (%data) = ();my (%com_data) = (); # Place tomy (@coms) = (); # List of all com ports availablemy (@com_list) = (); #list of all com ports usedmy (@com_handle);my ($mw, %timed_events, $start_btn, $stop_btn);my @display = (); # $display[dev#][chan#] Variable that the displays are mapped tomy @dispitem = (); # $dispitem[row][col] display item reference variable, used by TK grid placementmy ($config_file) = 'fdr.ini';my ($logfilehandle);my ($lastlogtime)=0;# Include all global variables that you want other modules to accessour (%devices, @device_list, %data);# Be sure to execute this AFTER all global variables have been definedmy (%config_data) = read_config_file($config_file);# Fill device list with "None";push(@device_list, 'None');load_modules();@coms = detect_commports();make_gui();MainLoop;# Save all config data back to filewrite_config_file($config_file, %config_data);exit;sub scan_data {   my ($device);   my ($dev_num);   my ($num_devices) = $config_data{devices}{number};   # Schedule next call to this function   $timed_events{next_scan}->after($config_data{rate}{scanrate}, \&scan_data);   read_comports();   # Send comport data to selected device decoding subroutine   for ($dev_num = 0; $dev_num < $num_devices; $dev_num++) {      $device = $device_type[$dev_num];      if (($com_list[$dev_num] ne 'None') & ($device ne 'None')) {         $com_data{$com_list[$dev_num]} = &{$devices{$device}{'sub'}}($dev_num, $com_data{$com_list[$dev_num]});      }   }}sub start_scan {   my ($dev_num);   my ($num_devices) = $config_data{devices}{number};   # Check to ensure that each com port is only selected once   my ($error, $com) = 0;   my (%temp) = ();   foreach $com (@com_list) {      if ((!defined($temp{$com})) or ($com eq 'None')) {         $temp{$com} = 1;      }      else {         $mw->Dialog(            -text => "Com port '$com' used more than once\nCannot start scanning",            -buttons => ['OK'],         ) ->Show;         $error = 1;      }   }   if ($error) {return};   # Open all selected com ports   for ($dev_num = 0; $dev_num < $num_devices; $dev_num++) {      $com_handle[$dev_num] = open_com_port($device_type[$dev_num], $com_list[$dev_num]);   }   my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time());   $mon++;   if ($year > 100) { $year -= 100; };   my $types = [ ['Comma Seperated Variable', '.csv'],                 ['Comma Seperated Variable', '.csv']               ];   # Get filename to save data to   my ($filename) = sprintf("%02.0f%02.0f%02.0f%02.0f%02.0f", $year, $mon, $mday, $hour, $min);   $filename = $mw->getSaveFile(      -initialdir => $config_data{outputfile}{defaultdir},      -initialfile => $filename,      -title => 'Save Output Data',      -filetypes => $types,      -defaultextension => '.csv',   );   if (defined($filename)) {      #$logfilehandle = \*STDOUT;      open(LOGFILE, ">$filename");      if (defined(\*LOGFILE)) {         $logfilehandle = \*LOGFILE;      }      else {         $mw->Dialog(            -text => "No log file will be saved\nCould not open file\n$filename",            -buttons => ['OK'],         ) ->Show;      }   }   else {      undef($logfilehandle);   }   # Print log file header information   if (defined($logfilehandle)) {      my (@chan_list, $chan);      print $logfilehandle "\"Time\"";      for ($dev_num = 0; $dev_num < $num_devices; $dev_num++) {         if ($device_type[$dev_num] ne 'None') {            @chan_list = @{$devices{$device_type[$dev_num]}{'fields'}};            foreach $chan (@chan_list) {               print $logfilehandle ",\"$device_type[$dev_num] $chan\"";            }         }      }      print $logfilehandle "\n";   }   $start_btn->configure(-state =>'disabled');   $stop_btn->configure(-state =>'active');   # Configure timed events   #Check for new data every x ms   $timed_events{next_scan}=$mw->Label;   scan_data(); # Event timing is defined in function   # Update displayed data every x ms   # Updating the display more that 10 times per sec (100 ms) is not   # reccomended as it makes it difficult to actually see the changing number.   $timed_events{display}=$mw->Label;   update_display(); # Event timing is defined in function   # Call and set log data file rate   if (defined($logfilehandle)) {      $timed_events{logdata}=$mw->Label;      save_log_data(); # Event timing is defined in function   }}sub stop_scan {   my ($dev_num);   my ($num_devices) = $config_data{devices}{number};   my ($events);   # Destroy ALL timed events   foreach $events (keys(%timed_events)) {      if(defined($timed_events{$events})) {         $timed_events{$events}->destroy;         undef($timed_events{$events});      }   }   # Close log file   if (defined($logfilehandle)) {      close($logfilehandle);   }   $start_btn->configure(-state =>'active');   $stop_btn->configure(-state =>'disabled');   # Close all com ports   for ($dev_num = 0; $dev_num < $num_devices; $dev_num++) {      $com_handle[$dev_num]->close if ($com_list[$dev_num] ne 'None');   }}sub read_comports {   my ($i, $dev_num);   my ($num_devices) = $config_data{devices}{number};   # Simulated com data   if ($simulate{serial} == 1) {      my ($rand1, $rand2);      for ($i = 0  ; $i < @com_list ; $i++) {         my ($rand1) = rand(100000);         my ($rand2) = sprintf("%04d", rand(10000));         # Simulate NMEA data         $com_data{$com_list[$i]} = "\$GPRMC,180432,A,$rand1,N,08704.857070,W,000.04,181.9,131000,1.8,W,D*25\x0D\x0A";         # Simulate D10A data         $com_data{$com_list[$i]} .= "00071717+109+00092450000+" . $rand2 . "+007-00+1099\x0D\x0A";      }   }   else {      # Actually read comports      # To Do      # Check if this actally works with read serial data      for ($dev_num = 0; $dev_num < $num_devices; $dev_num++) {         $com_handle[$dev_num]->input() if ($com_list[$dev_num] ne 'None');      }#      for ($i = 0  ; $i < @com_list ; $i++) {#         $com_data{$com_list[$i]} .= $com_handle[$i]->input();#      }   }}sub save_log_data {   # Save data from all devices to file   my @chan_list = ();   my ($device, $chan, @timearray, $time);   my ($sec,$min,$hour,$mday,$mon,$year, $secfrac, $systime);   my ($dev_num);   my ($num_devices) = $config_data{devices}{number};   # Schedule next call to this function   $timed_events{logdata}->after($config_data{rate}{logdata}, \&save_log_data);   # Get time, including milliseconds   $time = gettimeofday();   ($sec,$min,$hour,$mday,$mon,$year) = localtime($time);   $secfrac = $time - floor($time);   $mday++;   $year = $year+1900;   $sec = $sec + $secfrac;   $systime = sprintf ("%02.0f/%02.0f/%02.0f %02.0f:%02.0f:%02.3f", $mon,$mday,$year,$hour,$min,$sec);   # Time data saved to log file   print $logfilehandle $systime;   for ($dev_num = 0; $dev_num < $num_devices; $dev_num++) {      if ($device_type[$dev_num] ne 'None') {         @chan_list = @{$devices{$device_type[$dev_num]}{'fields'}};         foreach $chan (@chan_list) {            if (defined($data{$dev_num}{$chan})) {               print $logfilehandle ', ' . $data{$dev_num}{$chan};            }            else {               print $logfilehandle ', NaN';            }         }      }   }   print $logfilehandle "\n";}sub load_modules {   my ($module, @module_list, @files);   # Searches the current directry for all *.mod file   opendir(DIR, ".");   @module_list = grep(/\.mod$/,readdir(DIR));   closedir(DIR);   foreach $module (@module_list) {      require($module);   }}sub make_gui {   my ($row, $col);   my ($dev_num, @dev_select, @com_select);   my ($num_devices) = $config_data{devices}{number};   # Mainwindow: sizex/y, positionx/y   $mw = MainWindow->new;   $mw->geometry("+100+120");   for ($dev_num = 0; $dev_num < $num_devices ; $dev_num++) {      $dev_select[$dev_num] = $mw->Optionmenu(         -textvariable => \$device_type[$dev_num],         -options      => \@device_list,         -command      => [sub {disp_chanlist();}],      );      $com_select[$dev_num] = $mw->Optionmenu(         -textvariable => \$com_list[$dev_num],         -options      => \@coms,       );   }   # Setup defaults from config file   foreach $dev_num (keys(%{$config_data{modules}})) {      $device_type[$dev_num] = $config_data{modules}{$dev_num};   }   foreach $dev_num (keys(%{$config_data{comports}})) {      $com_list[$dev_num] = $config_data{comports}{$dev_num};   }   disp_chanlist();      $row = 1;   $col = 1;   $start_btn = $mw->Button(      -text    => 'Start Scan',      -command => \&start_scan,      -state   => 'active',   )->grid(-row => $row, -column => $col);   $col++;   $stop_btn = $mw->Button(      -text    => 'Stop Scan',      -command => \&stop_scan,      -state   => 'disabled',   )->grid(-row => $row, -column => $col);   $row++;   $col = 1;   for ($dev_num = 0; $dev_num < $num_devices ; $dev_num++) {      $dev_select[$dev_num]->grid(-row => $row, -column => $col);      $com_select[$dev_num]->grid(-row => $row, -column => $col + 1);      $col += 2;   }}sub disp_chanlist {   my ($dev_num);   my ($num_devices) = $config_data{devices}{number};   my ($col, $row, $device_name);   my ($channel, $junk);   my (@chan_list, $chan_num);   my ($start_row) = 3;   my ($start_col) = 1;   my @font = [ -size => $config_data{fonts}{size}, -weight => $config_data{fonts}{weight} ];   $col = $start_col;   # Remove ALL device display items and Tk references   for ($col = 1; $col <= ($num_devices*2); $col++) {      $row = $start_row;      while (Exists($dispitem[$row][$col])) {         $dispitem[$row][$col]->gridForget(); # Remove from display         $dispitem[$row][$col]->destroy; # Remove all Tk references         $row++;      }   }   # Create new display items (channel labels and data display items)   $col = $start_col;   for ($dev_num = 0; $dev_num < $num_devices ; $dev_num++) {      $row = $start_row;      $device_name = $device_type[$dev_num];      if (!exists($devices{$device_name})) { return; }            @chan_list = @{$devices{$device_name}{'fields'}};      $chan_num = 0;      foreach $channel (@chan_list) {         $dispitem[$row][$col]=$mw->Label(            -anchor => 'w',            -text => $channel,            -width => 10,            -font => @font,            )-> grid(            -row => $row,            -column => $col,         );         $dispitem[$row][$col+1]=$mw->Label(            -anchor => 'w',            -textvariable => \$display[$dev_num][$chan_num],            -width => 10,            -font => @font,            )-> grid(            -row => $row,            -column => $col+1,         );         $chan_num++;         $row++;      }      $col += 2;   }}sub update_display {   # Copies the data from the %data hash to the array linked to   # the display items, display_data[][]   my ($dev_num, $chan_num, $chan, @chan_list, $device_name);   my ($num_devices) = $config_data{devices}{number};   # Schedule next call to this function   $timed_events{display}->after($config_data{rate}{display}, \&update_display);   for ($dev_num = 0; $dev_num < $num_devices ; $dev_num++) {      $device_name = $device_type[$dev_num];      next if ($device_name eq 'None'); # Skip 'None' device      @chan_list = @{$devices{$device_name}{'fields'}};      $chan_num = 0;      foreach $chan (@chan_list) {         $display[$dev_num][$chan_num] = $data{$dev_num}{$chan};         $chan_num++;      }   }}sub detect_commports {   # Tries to autodetect available serial comm ports   # Returns list (array) of available serial ports   # Linux/Unix section needs to be tested.   my ($i, $port, $porthandle, @portlist, $quiet);   $quiet = 1; # Prevents error messages from being printed to STDERR   @portlist = ('None');   if ($OS_win) {      for ($i=1 ; $i <= 8 ; $i++){         $port = 'COM' . $i;         $porthandle = Win32::SerialPort->new ($port, $quiet);         if ($porthandle) {            $porthandle->close;            push(@portlist, $port);         }      }      undef $porthandle;   }   else { # Not win32, assuming Linux / MAC OS X / Unix      for ($i=0 ; $i <= 8 ; $i++){         $port = '/dev/ttyS' . $i;         $porthandle = Device::SerialPort->new ($port, $quiet);         if ($porthandle) {            $porthandle->close;            push(@portlist, $port);         }      }      undef $porthandle;   }   return (@portlist);}sub open_com_port {   my ($device_name, $port) = @_;   my @parameters = ();   my ($parameter, $value);   my ($porthandle, $command);   return(0) if (($device_name eq 'None') | ($port eq 'None'));   if ($OS_win) {      $porthandle = Win32::SerialPort->new ($port);   }   else {      $porthandle = Device::SerialPort->new ($port);   }   if (defined($porthandle)) {      # Read port configuration from device module and set port      @parameters = keys( %{$devices{$device_name}{'portconfig'}});      foreach $parameter (@parameters) {         $value = $devices{$device_name}{'portconfig'}{$parameter};         eval { $porthandle->$parameter($value); } ;      }      $porthandle->write_settings;      return($porthandle);   }   else {      $mw->Dialog(         -text => "Cannot open comm port '$port'",         -buttons => ['OK'],      ) ->Show;      return;   }}sub read_config_file {   my ($filename) = @_;   my (%hashdata) = ();   my ($line);   my ($section, $parameter, $value);   $parameter = "item";   $value = "number";   my ($start, $end);   open(INIFILE, '<' . $filename);   while (<INIFILE>) {      $line = $_;      $line =~ s/\x0a//;      $line =~ s/\x0d//;      # chomp($line);      ($parameter, $value) = '';      if (substr($line, 0,1) eq '#') {         # Comment line      }      elsif ($line =~ m/[[\S+]]/) {         $line =~ s/\x5b//;         $line =~ s/\x5d//;         $section = $line;      }      elsif ($line =~ m/[\S+]\x3d[\S+]/) {         ($parameter, $value) = split(/[\x3d]/, $line);      }      if (defined($section) & defined($parameter) & defined($value)) {         $hashdata{$section}{$parameter} = $value;      }   }   close(INIFILE);   return %hashdata;}sub write_config_file {   my ($filename, %hashdata) = @_;   my ($dev_num);   my ($num_devices) = $hashdata{devices}{number};   # Update device and com port settings    $hashdata{modules} = ();   $hashdata{comports} = ();   for ($dev_num = 0; $dev_num < $num_devices ; $dev_num++) {      $hashdata{modules}{$dev_num} = $device_type[$dev_num];      $hashdata{comports}{$dev_num} = $com_list[$dev_num];   }   my (@sections) = keys(%hashdata);   my (@parameters, $section, $parameter, $value);   open(INIFILE, '>' . $filename);   foreach $section (@sections) {      print INIFILE '[' . $section . ']' . "\n";      @parameters = keys(%{$hashdata{$section}});      foreach $parameter (@parameters) {         $value = $hashdata{$section}{$parameter};         print INIFILE "$parameter=$value\n";      }   }   close(INIFILE);}